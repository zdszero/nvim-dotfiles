# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet cl
	class ${1:MyClass} {
	 public:
		$1() = default;
		~$1() = default;
	
		$1 &operator=(const $1 &) = default;
		$1(const $1 &) = default;
	
		$1($1 &&) = default;
		$1 &operator=($1 &&) = default;
	
	 private:
		$2
	};
snippet usi
	using namespace ${1:std};$0
snippet new
	${1:auto *}${2:var} = new ${3:type}($4)
snippet tp
	template <typename ${1:_InputIter}>$0
snippet co
	std::cout << $0
snippet el
	std::endl;$0
snippet try
	try {
		
	} catch (const std::exception&) {
		$1
	}
snippet operator<< operator<< overloading
	friend std::ostream& operator<<(ostream &&os, const $1) {
		$0
		return os;
	}
snippet arr
	std::array<${1:T}, ${2:N}> $3;
snippet vec
	std::vector<${1:T}> $2;
snippet deq
	std::deque<${1:T}> $2;
snippet flis
	std::forward_list<${1:T}> $2;
snippet lis
	std::list<${1:T}> $2;
snippet set
	std::set<${1:T}> $2;
snippet map
	std::map<${1:Key}, ${2:T}> $3;
snippet mset
	std::multiset<${1:T}> $2;
snippet mmap
	std::multimap<${1:Key}, ${2:T}> $3;
snippet uset
	std::unordered_set<${1:T}> $2;
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> $3;
snippet umset
	std::unordered_multiset<${1:T}> $2;
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> $3;
snippet sta
	std::stack<${1:T}> $2;
snippet que
	std::queue<${1:T}> $2;
snippet pque
	std::priority_queue<${1:T}> $2;
snippet mut
	std::mutex ${1:m};
snippet lg
	std::lock_guard<${1:std::mutex}> ${2:lk}(${3:m});
snippet ul
	std::unique_lock<${1:std::mutex}> ${2:lk}(${3:m});
snippet cv
	std::condition_variable ${1:cv};
snippet str
	std::string $0
snippet msp
	std::shared_ptr<${1:T}> $2 = std::make_shared<$1>($3);
snippet amsp
	auto $1 = std::make_shared<${2:T}>($3);
snippet mup
	std::unique_ptr<${1:T}> $2 = std::make_unique<$1>($3);
snippet amup
	auto $1 = std::make_unique<${2:T}>($3);
snippet default_random_engine
	std::random_device rd;
	std::default_random_engine rng(rd());
	std::uniform_int_distribution<std::mt19937::result_type> dist(${1:range});
	// dist(rng)
snippet mt19937
	std::random_device rd;
	std::mt19937 rng(rd());
	std::uniform_int_distribution<std::mt19937::result_type> dist(${1:range});
	// dist(rng)
snippet delete_copy
	${1:name}(const $1&) = delete;
	$1& operator=(const $1&) = delete;
snippet delete_move
	${1:name}($1&&) = delete;
	$1& operator=($1&&) = delete;
snippet copy_move_macro
	// Macros to disable copying and moving
	#define DISALLOW_COPY(cname)                             \\
		cname(const cname &) = delete;            /* NOLINT */ \\
		cname &operator=(const cname &) = delete; /* NOLINT */
	
	#define DISALLOW_MOVE(cname)                        \\
		cname(cname &&) = delete;            /* NOLINT */ \\
		cname &operator=(cname &&) = delete; /* NOLINT */
	
	#define DISALLOW_COPY_AND_MOVE(cname) \\
		DISALLOW_COPY(cname);               \\
		DISALLOW_MOVE(cname);
snippet lambda
	[$1]($2) {
		$0
	};
snippet Test
	TEST(${1:SomethingTest}, ${2:SampleTest}) {
		$0
	}
snippet sort
	std::sort(${1:v}.begin(), $1.end());
snippet sortf
	std::sort(${1:v}.begin(), $1.end(), []($3 l, $3 r) {
		$4
	});
snippet fit
	for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); $1++) {
		$3
	}
snippet fin
	for ($1 : $2) {
		$3
	}
snippet be
	${1:container}.begin(), $1.end()
snippet test
	TEST(${1:test_suite_name}, ${2:test_name}) {
		$0
	}
snippet eeq
	EXPECT_EQ($1, $2);
snippet ene
	EXPECT_NE($1, $2);
snippet ege
	EXPECT_GE($1, $2);
snippet egt
	EXPECT_GT($1, $2);
snippet elt
	EXPECT_LT($1, $2);
snippet ele
	EXPECT_LE($1, $2);
snippet eth
	EXPECT_THROW($1, $2);
