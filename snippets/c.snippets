# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet def
	#define $0
snippet ndef
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif /* ifndef $1 */
snippet #if #if #endif
	#if ${1:0}
	${VISUAL}$0
	#endif
snippet once
	#ifndef $1
	#define $1
	
	$0
	
	#endif /* end of include guard: $1 */
snippet nocxx
	#ifdef __cplusplus
	extern "C" {
	#endif
	
	$0
	
	#ifdef __cplusplus
	} /* extern "C" */
	#endif
snippet td
	typedef ${1:int} ${2:MyCustomType};
snippet tde
	/*! \\enum $2
	 *
	 *  ${4:Detailed description}
	 */
	typedef enum {
		${1:Data} /*!< ${3:Description} */
	} ${2:foo};
snippet enum
	/*! \\enum $1
	 *
	 *  ${2:Detailed description}
	 */
	enum ${1:name} { $0 };
snippet inc
	#include <${1:.h}>
snippet main
	int main(int argc, char *argv[]) {
		${VISUAL}$0
		return 0;
	}
snippet Main
	int main() {
		${VISUAL}$0
		return 0;
	}
snippet st
	struct ${1:/* name */} {
		$2
	};$0
snippet enum
	typedef enum {
		$1
	} $0;
snippet fun
	${1:void} ${2:function_name}($3) {
		${VISUAL}$4
	}$0
snippet for
	for (${1:int }${2:i} = ${3:0}; $2 < ${4:count}; $2++) {
		${VISUAL}$0
	}
snippet forr
	for (${1:int }${2:upper} = ${3:0}; $2 >= ${4:lower}; $2--) {
		${VISUAL}$0
	}
snippet wh
	while (${1:/* condition */}) {
		${VISUAL}$2
	}
snippet do
	do {
		${VISUAL}$2
	} while(${1:/* condition */});$0
snippet if
	if (${1:/* condition */}) {
		${VISUAL}$0
	}
snippet el
	else {
		${VISUAL}$0
	}
snippet eli
	else if (${1:/* condition */}) {
		${VISUAL}$0
	}
snippet ife
	if (${1:/* condition */}) {
		$2
	} else {
		$3
	}$0
snippet sw
	switch ($1) {
	${VISUAL}$0
	}
snippet ca
	case ${1:/* condition */}:
		${VISUAL}$2
		break;$0
snippet de
	default:
		${VISUAL}$2
		break;$0
snippet pr
	printf("${1:%s}", $0);
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\\n"$3);
snippet getopt
	int choice;
	while (1)
	{
		static struct option long_options[] =
		{
			/* Use flags like so:
			{"verbose",	no_argument,	&verbose_flag, 'V'}*/
			/* Argument styles: no_argument, required_argument, optional_argument */
			{"version", no_argument,	0,	'v'},
			{"help",	no_argument,	0,	'h'},
			$1
			{0,0,0,0}
		};
	
		int option_index = 0;
	
		/* Argument parameters:
			no_argument: " "
			required_argument: ":"
			optional_argument: "::" */
	
		choice = getopt_long( argc, argv, "vh",
					long_options, &option_index);
	
		if (choice == -1)
			break;
	
		switch( choice )
		{
			case 'v':
				$2
				break;
	
			case 'h':
				$3
				break;
	
			case '?':
				/* getopt_long will have already printed an error */
				break;
	
			default:
				/* Not sure how to get here... */
				return EXIT_FAILURE;
		}
	}
	
	/* Deal with non-option arguments here */
	if ( optind < argc )
	{
		while ( optind < argc )
		{
			$0
		}
	}
snippet nonblock
	flags =  fcntl(fd, F_GETFL);
	flags |= O_NONBLOCK;
	fcntl(fd, F_SETFL, flags);
snippet block
	flags = fcntl(fd, F_GETFL)
	flags &= ~O_NONBLOCK;
	fcntl(fd, F_SETFL, flags);
